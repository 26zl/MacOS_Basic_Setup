name: Release

on:
  workflow_run:
    workflows: ["macOS Test"]
    types:
      - completed
  release:
    types: [created]
  workflow_dispatch:
    inputs:
      version:
        description: 'Release version (e.g., v1.0.0)'
        required: true
        type: string

permissions:
  contents: write
  actions: read

jobs:
  check-workflows:
    name: Check All Workflows Status
    runs-on: ubuntu-latest
    if: github.event_name == 'workflow_run'
    outputs:
      all-success: ${{ steps.check.outputs.all-success }}
    steps:
      - name: Wait for all workflows and check status
        id: check
        uses: actions/github-script@v7
        with:
          script: |
            const workflowRun = context.payload.workflow_run;
            const workflowName = workflowRun.name;
            const conclusion = workflowRun.conclusion;
            const headSha = workflowRun.head_sha;
            
            console.log(`Workflow "${workflowName}" completed with conclusion: ${conclusion}`);
            console.log(`Checking status of all workflows for commit: ${headSha}`);
            
            // Required workflows that must succeed
            const requiredWorkflows = ['Checks', 'macOS Test', 'Security Scan'];
            
            // Wait a bit for all workflows to complete (they might finish almost simultaneously)
            await new Promise(resolve => setTimeout(resolve, 10000));
            
            // Get all workflow runs for this commit
            let allCompleted = false;
            let attempts = 0;
            const maxAttempts = 30; // Wait up to 5 minutes (30 * 10 seconds)
            
            while (!allCompleted && attempts < maxAttempts) {
              attempts++;
              const { data: runs } = await github.rest.actions.listWorkflowRunsForRepo({
                owner: context.repo.owner,
                repo: context.repo.repo,
                head_sha: headSha,
                per_page: 100
              });
              
              const workflowStatuses = {};
              
              // Check status of all required workflows
              for (const run of runs.workflow_runs) {
                if (requiredWorkflows.includes(run.name)) {
                  workflowStatuses[run.name] = {
                    status: run.status,
                    conclusion: run.conclusion,
                    id: run.id
                  };
                }
              }
              
              // Check if all required workflows are present and completed
              allCompleted = true;
              let allSuccess = true;
              
              for (const reqWorkflow of requiredWorkflows) {
                const status = workflowStatuses[reqWorkflow];
                if (!status) {
                  console.log(`WAITING: Workflow "${reqWorkflow}" not found yet (attempt ${attempts}/${maxAttempts})`);
                  allCompleted = false;
                  break;
                }
                
                if (status.status !== 'completed') {
                  console.log(`WAITING: Workflow "${reqWorkflow}" is still running (status: ${status.status}, attempt ${attempts}/${maxAttempts})`);
                  allCompleted = false;
                  break;
                }
                
                if (status.conclusion !== 'success') {
                  console.log(`ERROR: Workflow "${reqWorkflow}" failed (conclusion: ${status.conclusion})`);
                  allSuccess = false;
                } else {
                  console.log(`OK: Workflow "${reqWorkflow}" succeeded`);
                }
              }
              
              if (allCompleted) {
                if (!allSuccess) {
                  console.log('ERROR: One or more workflows failed. Release will not be created.');
                  core.setOutput('all-success', 'false');
                  return;
                }
                break;
              }
              
              // Wait before next check
              if (attempts < maxAttempts) {
                console.log(`Waiting 10 seconds before next check... (attempt ${attempts}/${maxAttempts})`);
                await new Promise(resolve => setTimeout(resolve, 10000));
              }
            }
            
            if (!allCompleted) {
              console.log('TIMEOUT: Not all workflows completed within the timeout period. Release will not be created.');
              core.setOutput('all-success', 'false');
              return;
            }
            
            console.log('OK: All required workflows succeeded! Proceeding with release...');
            core.setOutput('all-success', 'true');

  create-release:
    name: Create Release Package
    runs-on: ubuntu-latest
    needs: [check-workflows]
    # Only run if all workflows succeeded or if triggered manually/release
    if: |
      always() && (
        (github.event_name == 'workflow_run' && needs.check-workflows.outputs.all-success == 'true') ||
        github.event_name == 'release' ||
        github.event_name == 'workflow_dispatch'
      )
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          fetch-tags: true

      - name: Get version
        id: version
        run: |
          if [ "${{ github.event_name }}" == "workflow_dispatch" ]; then
            VERSION="${{ github.event.inputs.version }}"
          elif [ "${{ github.event_name }}" == "release" ]; then
            VERSION="${GITHUB_REF#refs/tags/}"
          elif [ "${{ github.event_name }}" == "workflow_run" ]; then
            # Auto-generate version based on date and commit SHA
            COMMIT_SHA="${{ github.event.workflow_run.head_sha }}"
            SHORT_SHA="${COMMIT_SHA:0:7}"
            DATE=$(date +%Y.%m.%d)
            VERSION="v${DATE}-${SHORT_SHA}"
            echo "Auto-generated version: $VERSION"
          fi
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "Release version: $VERSION"

      - name: Create release package
        id: package
        run: |
          VERSION="${{ steps.version.outputs.version }}"
          PACKAGE_NAME="MacOS-Dev-Setup-${VERSION}"
          mkdir -p "$PACKAGE_NAME"
          
          # Copy all files and directories except .git, .github/workflows, and build artifacts
          find . -mindepth 1 -maxdepth 1 \
            ! -name '.git' \
            ! -name '.github' \
            ! -name "$PACKAGE_NAME" \
            ! -name '*.zip' \
            ! -name '*.sha256' \
            ! -name '.DS_Store' \
            ! -name '__MACOSX' \
            ! -name '._*' \
            -exec cp -r {} "$PACKAGE_NAME/" \;
          
          # Copy .github directory but exclude workflows subdirectory
          if [ -d ".github" ]; then
            mkdir -p "$PACKAGE_NAME/.github"
            find .github -mindepth 1 -maxdepth 1 ! -name 'workflows' -exec cp -r {} "$PACKAGE_NAME/.github/" \;
          fi
          
          # Remove macOS system files from the package directory
          find "$PACKAGE_NAME" -name '.DS_Store' -delete
          find "$PACKAGE_NAME" -name '__MACOSX' -type d -exec rm -rf {} + 2>/dev/null || true
          find "$PACKAGE_NAME" -name '._*' -delete
          find "$PACKAGE_NAME" -name '.AppleDouble' -type d -exec rm -rf {} + 2>/dev/null || true
          find "$PACKAGE_NAME" -name '.LSOverride' -delete
          
          # Create zip file (exclude system files and build artifacts)
          cd "$PACKAGE_NAME"
          zip -r "../${PACKAGE_NAME}.zip" . \
            -x "*.git*" \
            -x "*.DS_Store" \
            -x "*__MACOSX*" \
            -x "*._*" \
            -x "*.AppleDouble*" \
            -x "*__pycache__*" \
            -x "*.pyc" \
            -x "*.pyo" \
            -x "*.swp" \
            -x "*.swo" \
            -x "*~"
          cd ..
          
          # Create checksums
          sha256sum "${PACKAGE_NAME}.zip" > "${PACKAGE_NAME}.zip.sha256"
          
          # Set outputs
          echo "zip_file=${PACKAGE_NAME}.zip" >> $GITHUB_OUTPUT
          echo "checksum_file=${PACKAGE_NAME}.zip.sha256" >> $GITHUB_OUTPUT
          
          # Read checksum content for release notes
          CHECKSUM_CONTENT=$(cat "${PACKAGE_NAME}.zip.sha256")
          echo "checksum_content<<EOF" >> $GITHUB_OUTPUT
          echo "$CHECKSUM_CONTENT" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      - name: Create Release
        uses: softprops/action-gh-release@v1
        with:
          tag_name: ${{ steps.version.outputs.version }}
          name: Release ${{ steps.version.outputs.version }}
          body: |
            ## macOS Development Environment Setup ${{ steps.version.outputs.version }}
            
            ### Installation
            1. Download and extract the zip file
            2. Run `./install.sh` for shell setup (Oh My Zsh, terminal config)
            3. (Optional) Run `./dev-tools.sh` to install package managers and language tools
            
            ### Files included
            All project files are included in this release except GitHub workflow files (`.github/workflows/`).
            
            Main files:
            - `install.sh` - Shell setup installation script
            - `dev-tools.sh` - Development tools installation script (language package managers, version managers, and language runtimes)
            - `zsh.sh` - Zsh configuration
            - `maintain-system.sh` - System maintenance script
            - `scripts/` - Additional maintenance scripts
            - `background/` - Terminal background images
            - `README.md` - Documentation
            - `LICENSE` - License file
            - `Ghostty config.txt` - Terminal configuration
            - `quick-test.sh` - Quick test script
            - And all other project files
            
            ### Checksums
            ```
            ${{ steps.package.outputs.checksum_content }}
            ```
          files: |
            ${{ steps.package.outputs.zip_file }}
            ${{ steps.package.outputs.checksum_file }}
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Upload artifacts
        uses: actions/upload-artifact@v4
        with:
          name: release-package
          path: |
            ${{ steps.package.outputs.zip_file }}
            ${{ steps.package.outputs.checksum_file }}
